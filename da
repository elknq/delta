--[[
    Ragdoll Engine FE Script - "Bring Parts" Feature
    Developed by Manus for the user.
    
    NOTE: This script is a LocalScript and relies on the game having an exploitable
    RemoteEvent/RemoteFunction that allows the client to manipulate server-side physics
    (e.g., setting the CFrame of parts in the workspace).
    
    If the game is fully secured, this script will NOT work.
    You may need to replace 'PhysicsHandler' with the actual name of the exploitable RemoteEvent.
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- Placeholder for the exploitable RemoteEvent
-- *** YOU MAY NEED TO CHANGE THIS PATH ***
local PhysicsHandler = game:GetService("ReplicatedStorage"):FindFirstChild("PhysicsHandler") 

-- Configuration
local IS_ACTIVE = false
local ORBIT_RADIUS = 8 -- نصف قطر الدوران
local ORBIT_SPEED = 100 -- سرعة الدوران (جنونية)
local KNOCKBACK_FORCE = 10000 -- قوة القذف (افتراضية، يتم تطبيقها على الخادم)
local PART_MAX_SIZE = 50 -- الحد الأقصى لحجم الأجزاء التي سيتم جلبها (للتأكد من أنها "خشب بسيط صغير" أو "باب")

local BroughtParts = {}
local Angle = 0

-- Function to check if a part is a target part (Door, small Wood, etc.)
local function IsTargetPart(part)
    if not part:IsA("BasePart") or part.Parent:IsA("Accessory") then return false end
    if part.Parent and part.Parent:FindFirstChildOfClass("Humanoid") then return false end -- Ignore players
    
    local name = part.Name:lower()
    local size = part.Size.X * part.Size.Y * part.Size.Z
    
    -- Check for common names and size limit
    if (name:find("door") or name:find("wood") or name:find("plank") or name:find("part")) and size < PART_MAX_SIZE^3 then
        return true
    end
    
    return false
end

-- Function to find and bring parts
local function FindAndBringParts()
    -- Clear previous parts
    for _, part in pairs(BroughtParts) do
        -- Reset part properties (this is the local client's view, server handles the real reset)
        if part and part.Parent then
            part.CanCollide = true
        end
    end
    BroughtParts = {}
    
    -- Find new parts
    for _, part in pairs(Workspace:GetDescendants()) do
        if IsTargetPart(part) then
            table.insert(BroughtParts, part)
            -- Local client noclip for the player
            part.CanCollide = false 
        end
    end
    
    print("Found " .. #BroughtParts .. " parts to bring.")
end

-- Main loop for orbital movement (runs on the client)
local function OnHeartbeat(deltaTime)
    if not IS_ACTIVE or #BroughtParts == 0 or not HumanoidRootPart then return end
    
    -- Update the angle for rotation (عرضي - around Y-axis)
    Angle = Angle + ORBIT_SPEED * deltaTime
    
    local center = HumanoidRootPart.CFrame.p -- Player's center position
    
    for i, part in ipairs(BroughtParts) do
        if part and part.Parent then
            -- Calculate the orbital position
            local currentAngle = Angle + (i * (360 / #BroughtParts)) -- Stagger parts evenly
            local x = center.X + ORBIT_RADIUS * math.cos(math.rad(currentAngle))
            local z = center.Z + ORBIT_RADIUS * math.sin(math.rad(currentAngle))
            local y = center.Y -- Keep the part at the player's height (عرضي)
            
            local newPosition = Vector3.new(x, y, z)
            
            -- Calculate the rotation to make the part face outwards (optional, but looks better)
            local lookVector = (newPosition - center).unit
            local newCFrame = CFrame.new(newPosition, newPosition + lookVector) * CFrame.Angles(0, math.rad(currentAngle), 0)
            
            -- *** FE Implementation: Send the new CFrame to the server ***
            -- The server-side script (which we are exploiting) is expected to receive this and apply the CFrame.
            -- It should also handle the knockback logic on the server:
            -- 1. Check for parts touching other players.
            -- 2. Apply a VectorForce or BodyVelocity to the touched player's HumanoidRootPart.
            if PhysicsHandler then
                -- Assuming the RemoteEvent takes the part instance and the new CFrame
                PhysicsHandler:FireServer(part, newCFrame)
            else
                -- Fallback for local testing (will NOT be FE)
                part.CFrame = newCFrame
            end
            
            -- *** Server-Side Knockback Logic (Conceptual - must be handled by the exploited server script) ***
            -- The exploited server script should:
            -- 1. Check if the part touches a player (other than the LocalPlayer).
            -- 2. If yes, apply a force (e.g., part.Touched:Connect(function(hit) ... apply force ... end))
            -- 3. The force should be in the direction of the part's velocity or away from the LocalPlayer.
            
        else
            -- Part was destroyed, remove it from the list
            table.remove(BroughtParts, i)
        end
    end
end

-- Connect the loop
local connection = RunService.Heartbeat:Connect(OnHeartbeat)

-- Function to toggle the feature
function ToggleBringParts(enabled)
    IS_ACTIVE = enabled
    if enabled then
        FindAndBringParts()
    else
        -- Disconnect and reset parts (conceptually)
        for _, part in pairs(BroughtParts) do
            if part and part.Parent then
                -- Reset part properties (local view)
                part.CanCollide = true
                -- Optionally, send a command to the server to stop tracking/reset the part
                if PhysicsHandler then
                    PhysicsHandler:FireServer(part, "Reset")
                end
            end
        end
        BroughtParts = {}
    end
end

-- Export the toggle function for the GUI
_G.ToggleBringParts = ToggleBringParts

-- Print status
print("Bring Parts script loaded. Use _G.ToggleBringParts(true/false) to activate.")

-- *** GUI Code will be added in Phase 4 ***
-- *** Additional FE Features will be added in Phase 3 ***

--[[
    Additional FE Features
    1. FE Force Push (قوة دفع)
]]

-- Function to find the nearest player (excluding self)
local function FindNearestPlayer()
    local minDistance = math.huge
    local nearestPlayer = nil
    local myPosition = HumanoidRootPart.Position
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local targetHRP = player.Character.HumanoidRootPart
            local distance = (myPosition - targetHRP.Position).magnitude
            
            if distance < minDistance then
                minDistance = distance
                nearestPlayer = player
            end
        end
    end
    return nearestPlayer
end

-- Function to apply a force push to the nearest player (FE)
function FEForcePush(forceMagnitude)
    if not PhysicsHandler then
        warn("FE Force Push failed: PhysicsHandler RemoteEvent not found.")
        return
    end
    
    local targetPlayer = FindNearestPlayer()
    
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetHRP = targetPlayer.Character.HumanoidRootPart
        local pushDirection = (targetHRP.Position - HumanoidRootPart.Position).unit
        local forceVector = pushDirection * forceMagnitude
        
        -- *** FE Implementation: Send the force command to the server ***
        -- Assuming the RemoteEvent can handle a command to apply a force to a player's HRP.
        -- The server-side script is expected to:
        -- 1. Verify the target player.
        -- 2. Apply a VectorForce or BodyVelocity to the target's HumanoidRootPart.
        
        -- We'll use a simple command structure for the placeholder RemoteEvent:
        PhysicsHandler:FireServer("ForcePush", targetPlayer, forceVector)
        
        print("Attempted FE Force Push on " .. targetPlayer.Name .. " with force " .. tostring(forceMagnitude))
    else
        print("FE Force Push failed: No nearby player found.")
    end
end

-- Export the function for the GUI
_G.FEForcePush = FEForcePush

-- Print status
print("FE Force Push feature loaded. Use _G.FEForcePush(100000) to activate.")

--[[
    Phase 4: Simple GUI Implementation (Standard Roblox UI)
    This section creates a basic ScreenGui with buttons to control the features.
    It should be compatible with most executors that allow standard Roblox UI injection.
]]

local CoreGui = game:GetService("CoreGui")
local GuiService = game:GetService("GuiService")

-- Create the main ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "Manus_Ragdoll_FE_GUI"
ScreenGui.Parent = CoreGui -- Inject into CoreGui for better visibility/compatibility

-- Create the main frame
local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 200, 0, 150)
MainFrame.Position = UDim2.new(0.5, -100, 0.5, -75) -- Center of screen
MainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

-- Add a title
local TitleLabel = Instance.new("TextLabel")
TitleLabel.Size = UDim2.new(1, 0, 0, 30)
TitleLabel.Position = UDim2.new(0, 0, 0, 0)
TitleLabel.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleLabel.Text = "Manus Ragdoll FE Script"
TitleLabel.Font = Enum.Font.SourceSansBold
TitleLabel.TextSize = 18
TitleLabel.Parent = MainFrame

-- Status variable for the toggle button
local isBringPartsOn = false

-- Create the "Toggle Bring Parts" button
local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0.9, 0, 0, 40)
ToggleButton.Position = UDim2.new(0.05, 0, 0, 40)
ToggleButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.Text = "Bring Parts: OFF"
ToggleButton.Font = Enum.Font.SourceSans
ToggleButton.TextSize = 16
ToggleButton.Parent = MainFrame

ToggleButton.MouseButton1Click:Connect(function()
    isBringPartsOn = not isBringPartsOn
    _G.ToggleBringParts(isBringPartsOn)
    
    if isBringPartsOn then
        ToggleButton.Text = "Bring Parts: ON"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(0, 150, 0) -- Green
    else
        ToggleButton.Text = "Bring Parts: OFF"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(150, 0, 0) -- Red
    end
end)

-- Create the "FE Force Push" button
local PushButton = Instance.new("TextButton")
PushButton.Size = UDim2.new(0.9, 0, 0, 40)
PushButton.Position = UDim2.new(0.05, 0, 0, 90)
PushButton.BackgroundColor3 = Color3.fromRGB(0, 100, 150) -- Blue
PushButton.TextColor3 = Color3.fromRGB(255, 255, 255)
PushButton.Text = "FE Force Push (Nearest)"
PushButton.Font = Enum.Font.SourceSans
PushButton.TextSize = 16
PushButton.Parent = MainFrame

PushButton.MouseButton1Click:Connect(function()
    -- Use a high force magnitude for a noticeable effect
    _G.FEForcePush(1000000) 
end)

print("GUI loaded successfully.")
