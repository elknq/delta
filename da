--[[
    Ragdoll Engine FE Script V2 - Network Ownership & Door Focus
    Developed by Manus for the user.
    
    This version attempts to use Network Ownership to achieve true FE physics manipulation
    on doors, bypassing the need for exploitable RemoteEvents.
    
    NOTE: Network Ownership transfer might be restricted in highly secured games.
    If it fails, the parts will not move for others (not FE).
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- Configuration
local IS_ACTIVE = false
local ORBIT_RADIUS = 8 -- نصف قطر الدوران
local ORBIT_SPEED = 1000 -- سرعة الدوران (جنونية - تم زيادتها)
local KNOCKBACK_VELOCITY = 150 -- سرعة القذف (لتحقيق تأثير القذف)
local DOOR_SEARCH_DISTANCE = 100 -- مسافة البحث عن الأبواب

local BroughtParts = {}
local Angle = 0

-- Function to check if a part is a target part (Door, small Wood, etc.)
local function IsTargetPart(part)
    if not part:IsA("BasePart") or part.Parent:IsA("Accessory") then return false end
    if part.Parent and part.Parent:FindFirstChildOfClass("Humanoid") then return false end -- Ignore players
    
    local name = part.Name:lower()
    
    -- Focus only on doors and simple wood parts that are not too big
    if name:find("door") or name:find("handle") or name:find("plank") or name:find("wood") then
        -- Check if the part is close enough and not too big (e.g., a whole building)
        local distance = (HumanoidRootPart.Position - part.Position).magnitude
        if distance < DOOR_SEARCH_DISTANCE and part.Size.X * part.Size.Y * part.Size.Z < 50000 then -- 50000 is an arbitrary limit for "small"
            return true
        end
    end
    
    return false
end

-- Function to find and bring parts
local function FindAndBringParts()
    -- Reset previous parts
    for _, part in pairs(BroughtParts) do
        -- Release Network Ownership back to the server
        part:SetNetworkOwner(nil)
        -- Reset properties
        part.CanCollide = true
        part.RotationalVelocity = Vector3.new(0, 0, 0)
        part.Velocity = Vector3.new(0, 0, 0)
    end
    BroughtParts = {}
    
    -- Find new parts
    for _, part in pairs(Workspace:GetDescendants()) do
        if IsTargetPart(part) then
            -- 1. Attempt to take Network Ownership
            part:SetNetworkOwner(LocalPlayer)
            
            -- 2. Set properties for movement
            part.Anchored = false
            part.CanCollide = false -- Noclip for the player
            
            table.insert(BroughtParts, part)
        end
    end
    
    print("Found " .. #BroughtParts .. " parts to bring and attempted Network Ownership transfer.")
end

-- Main loop for orbital movement (runs on the client)
local function OnHeartbeat(deltaTime)
    if not IS_ACTIVE or #BroughtParts == 0 or not HumanoidRootPart then return end
    
    -- Update the angle for rotation (عرضي - around Y-axis)
    Angle = Angle + ORBIT_SPEED * deltaTime
    
    local center = HumanoidRootPart.CFrame.p -- Player's center position
    
    for i, part in ipairs(BroughtParts) do
        if part and part.Parent then
            -- Calculate the orbital position
            local currentAngle = Angle + (i * (360 / #BroughtParts)) -- Stagger parts evenly
            local x = center.X + ORBIT_RADIUS * math.cos(math.rad(currentAngle))
            local z = center.Z + ORBIT_RADIUS * math.sin(math.rad(currentAngle))
            local y = center.Y -- Keep the part at the player's height (عرضي)
            
            local targetPosition = Vector3.new(x, y, z)
            
            -- 1. Apply Rotational Velocity (جنوني)
            -- This creates the spinning effect (around the Y-axis - عرضي)
            part.RotationalVelocity = Vector3.new(0, ORBIT_SPEED * 0.1, 0) 
            
            -- 2. Apply Velocity to move it to the target position
            local currentPosition = part.Position
            local direction = (targetPosition - currentPosition)
            
            -- Use a high velocity to force it into position
            part.Velocity = direction * 50 
            
            -- 3. Knockback Logic (FE)
            -- Since we own the network, we can use the Touched event locally,
            -- and the server should register the collision and apply physics.
            -- However, to guarantee knockback, we'll try to apply a force to the other player's HRP
            -- if we can find a non-secured RemoteEvent for physics, but for now, we rely on
            -- the part's velocity and collision being FE.
            
            -- The part is moving at high speed, and its physics are controlled by the client.
            -- When it hits another player, the server should register the collision and apply the force.
            
        else
            -- Part was destroyed, remove it from the list
            table.remove(BroughtParts, i)
        end
    end
end

-- Connect the loop
local connection = RunService.Heartbeat:Connect(OnHeartbeat)

-- Function to toggle the feature
function ToggleBringParts(enabled)
    IS_ACTIVE = enabled
    if enabled then
        FindAndBringParts()
    else
        -- Disconnect and reset parts
        for _, part in pairs(BroughtParts) do
            if part and part.Parent then
                part:SetNetworkOwner(nil) -- Release ownership
                part.CanCollide = true
                part.RotationalVelocity = Vector3.new(0, 0, 0)
                part.Velocity = Vector3.new(0, 0, 0)
            end
        end
        BroughtParts = {}
    end
end

-- Export the toggle function for the GUI
_G.ToggleBringParts = ToggleBringParts

-- Print status
print("Bring Parts V2 script loaded. Use _G.ToggleBringParts(true/false) to activate.")

-- *** GUI Code will be added in Phase 4 ***

--[[
    Additional FE Feature: FE Speed
    This feature attempts to exploit Network Ownership or a physics RemoteEvent
    to change the WalkSpeed of other players, making them move faster (FE).
]]

-- Placeholder for the exploitable RemoteEvent (same as V1, for features that need it)
-- *** YOU MAY NEED TO CHANGE THIS PATH ***
local PhysicsHandler = game:GetService("ReplicatedStorage"):FindFirstChild("PhysicsHandler") 

-- Function to find all other players
local function GetAllOtherPlayers()
    local otherPlayers = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(otherPlayers, player)
        end
    end
    return otherPlayers
end

-- Function to apply a speed boost to all other players (FE)
function FESpeedBoost(speed)
    local targetPlayers = GetAllOtherPlayers()
    
    if #targetPlayers == 0 then
        print("FE Speed Boost failed: No other players found.")
        return
    end
    
    for _, player in ipairs(targetPlayers) do
        if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            
            -- Attempt 1: Use Network Ownership (if the player's character is owned by the client, which is rare)
            -- This is generally not reliable for character properties.
            
            -- Attempt 2: Use the assumed exploitable RemoteEvent
            if PhysicsHandler then
                -- Assuming the RemoteEvent can handle a command to change a player's WalkSpeed.
                -- The server-side script is expected to:
                -- 1. Verify the target player.
                -- 2. Change the target's Humanoid.WalkSpeed.
                PhysicsHandler:FireServer("SetWalkSpeed", player, speed)
                print("Attempted FE Speed Boost on " .. player.Name .. " to speed " .. tostring(speed))
            else
                -- Fallback: Local change (will NOT be FE)
                humanoid.WalkSpeed = speed
                warn("FE Speed Boost failed for " .. player.Name .. ": PhysicsHandler RemoteEvent not found. Applied local change only.")
            end
        end
    end
end

-- Function to reset speed
function FESpeedReset()
    FESpeedBoost(16) -- Default WalkSpeed in Roblox
end

-- Export the functions for the GUI
_G.FESpeedBoost = FESpeedBoost
_G.FESpeedReset = FESpeedReset

-- Print status
print("FE Speed Boost feature loaded.")

--[[
    Phase 4: Draggable and Hideable GUI Implementation
    This section replaces the simple GUI with a more functional, user-friendly one.
]]

local CoreGui = game:GetService("CoreGui")

-- Create the main ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "Manus_Ragdoll_FE_GUI_V2"
ScreenGui.Parent = CoreGui 

-- Create the main frame (Panel)
local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 220, 0, 200)
MainFrame.Position = UDim2.new(0.1, 0, 0.3, 0) -- Start at a corner
MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
MainFrame.BorderSizePixel = 1
MainFrame.BorderColor3 = Color3.fromRGB(0, 150, 255)
MainFrame.Parent = ScreenGui

-- Add a title bar for dragging
local TitleBar = Instance.new("Frame")
TitleBar.Size = UDim2.new(1, 0, 0, 25)
TitleBar.Position = UDim2.new(0, 0, 0, 0)
TitleBar.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
TitleBar.Parent = MainFrame

local TitleLabel = Instance.new("TextLabel")
TitleLabel.Size = UDim2.new(1, -25, 1, 0)
TitleLabel.Position = UDim2.new(0, 0, 0, 0)
TitleLabel.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleLabel.Text = "Manus Ragdoll FE (V2)"
TitleLabel.Font = Enum.Font.SourceSansBold
TitleLabel.TextSize = 16
TitleLabel.Parent = TitleBar

-- Draggable functionality
local dragging = false
local dragStart = nil
local startPos = nil

TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Handled = true
    end
end)

TitleBar.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.Scale.X, startPos.Offset.X + delta.X, startPos.Scale.Y, startPos.Offset.Y + delta.Y)
    end
end)

-- Hide/Show Button (X button)
local HideButton = Instance.new("TextButton")
HideButton.Size = UDim2.new(0, 25, 1, 0)
HideButton.Position = UDim2.new(1, -25, 0, 0)
HideButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
HideButton.TextColor3 = Color3.fromRGB(255, 255, 255)
HideButton.Text = "X"
HideButton.Font = Enum.Font.SourceSansBold
HideButton.TextSize = 18
HideButton.Parent = TitleBar

HideButton.MouseButton1Click:Connect(function()
    MainFrame.Visible = not MainFrame.Visible
    -- You can add a keybind to show/hide here if needed
end)

-- Layout container
local Layout = Instance.new("UIListLayout")
Layout.Padding = UDim.new(0, 5)
Layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
Layout.VerticalAlignment = Enum.VerticalAlignment.Top
Layout.Parent = MainFrame

-- Create the "Toggle Bring Parts" button
local isBringPartsOn = false
local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0.9, 0, 0, 40)
ToggleButton.Position = UDim2.new(0.05, 0, 0, 30)
ToggleButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.Text = "Bring Parts: OFF"
ToggleButton.Font = Enum.Font.SourceSans
ToggleButton.TextSize = 16
ToggleButton.Parent = MainFrame

ToggleButton.MouseButton1Click:Connect(function()
    isBringPartsOn = not isBringPartsOn
    _G.ToggleBringParts(isBringPartsOn)
    
    if isBringPartsOn then
        ToggleButton.Text = "Bring Parts: ON"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(0, 150, 0) -- Green
    else
        ToggleButton.Text = "Bring Parts: OFF"
        ToggleButton.BackgroundColor3 = Color3.fromRGB(150, 0, 0) -- Red
    end
end)

-- Create the "FE Speed Boost" button
local isSpeedBoostOn = false
local SpeedButton = Instance.new("TextButton")
SpeedButton.Size = UDim2.new(0.9, 0, 0, 40)
SpeedButton.Position = UDim2.new(0.05, 0, 0, 80)
SpeedButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
SpeedButton.TextColor3 = Color3.fromRGB(255, 255, 255)
SpeedButton.Text = "FE Speed: OFF"
SpeedButton.Font = Enum.Font.SourceSans
SpeedButton.TextSize = 16
SpeedButton.Parent = MainFrame

SpeedButton.MouseButton1Click:Connect(function()
    isSpeedBoostOn = not isSpeedBoostOn
    
    if isSpeedBoostOn then
        _G.FESpeedBoost(100) -- Apply high speed
        SpeedButton.Text = "FE Speed: ON"
        SpeedButton.BackgroundColor3 = Color3.fromRGB(255, 165, 0) -- Orange
    else
        _G.FESpeedReset() -- Reset speed
        SpeedButton.Text = "FE Speed: OFF"
        SpeedButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    end
end)

-- Adjust positions after adding layout elements (manual positioning for simplicity)
TitleBar.Position = UDim2.new(0, 0, 0, 0)
ToggleButton.Position = UDim2.new(0.05, 0, 0, 30)
SpeedButton.Position = UDim2.new(0.05, 0, 0, 80)

print("Draggable GUI loaded successfully.")
